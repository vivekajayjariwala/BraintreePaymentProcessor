{"ast":null,"code":"/* eslint-disable */\n/*\n * querystring-parse.js\n *  - node.js module providing \"parse\" method to turn query strings into js objects\n *\n * Chad Etzel\n *\n * Based on YUI \"querystring-parse.js\" module\n * http://github.com/isaacs/yui3/tree/master/src/querystring/js\n *\n * Copyright (c) 2009, Yahoo! Inc. and Chad Etzel\n * BSD License (see LICENSE.md for info)\n */\n\nvar util = require(\"util\"),\n  braintree_util = require(\"./util\");\nexports.parse = querystring_parse;\n\n/**\n * <p>The querystring module adds support for serializing JavaScript objects into\n * query strings and parsing JavaScript objects from query strings format.</p>\n *\n * <p>The <code>querystring</code> module is a rollup of <code>querystring-parse</code> and\n * <code>querystring-stringify</code>.</p>\n *\n * <p>As their names suggest, <code>querystring-parse</code> adds support for parsing\n * Query String data (querystring.parse) and <code>querystring-stringify</code> for serializing\n * JavaScript data into Query Strings (querystring.stringify).  You may choose to\n * include either of the submodules individually if you don't need the\n * complementary functionality, or include the rollup for both.</p>\n *\n * @module querystring\n */\n\n/**\n * Provides parse method to accept Query Strings and return native\n * JavaScript objects.\n *\n * @module querystring\n * @submodule querystring-parse\n * @for querystring\n * @static\n */\nfunction querystring_parse(qs, sep, eq, unesc) {\n  return qs.split(sep || \"&\").map(pieceParser(eq || \"=\", unesc || unescape)).reduce(mergeParams, {});\n}\n;\nfunction unescape(s) {\n  return decodeURIComponent(s.replace(/\\+/g, ' '));\n}\n;\n\n// Parse a key=val string.\n// These can get pretty hairy\n// example flow:\n// parse(foo[bar][][bla]=baz)\n// return parse(foo[bar][][bla],\"baz\")\n// return parse(foo[bar][], {bla : \"baz\"})\n// return parse(foo[bar], [{bla:\"baz\"}])\n// return parse(foo, {bar:[{bla:\"baz\"}]})\n// return {foo:{bar:[{bla:\"baz\"}]}}\nfunction pieceParser(eq, unesc) {\n  return function parsePiece(key, val) {\n    if (arguments.length !== 2) {\n      // key=val, called from the map/reduce\n      key = key.split(eq);\n      return parsePiece(unesc(key.shift()), unesc(key.join(eq)));\n    }\n    key = key.replace(/^\\s+|\\s+$/g, '');\n    if (braintree_util.isString(val)) {\n      val = val.replace(/^\\s+|\\s+$/g, '');\n      // convert numerals to numbers\n      if (!isNaN(val)) {\n        var numVal = +val;\n        if (val === numVal.toString(10)) val = numVal;\n      }\n    }\n    var sliced = /(.*)\\[([^\\]]*)\\]$/.exec(key);\n    if (!sliced) {\n      var ret = {};\n      if (key) ret[key] = val;\n      return ret;\n    }\n    // [\"foo[][bar][][baz]\", \"foo[][bar][]\", \"baz\"]\n    var tail = sliced[2],\n      head = sliced[1];\n\n    // array: key[]=val\n    if (!tail) return parsePiece(head, [val]);\n\n    // obj: key[subkey]=val\n    var ret = {};\n    ret[tail] = val;\n    return parsePiece(head, ret);\n  };\n}\n;\n\n// the reducer function that merges each query piece together into one set of params\nfunction mergeParams(params, addition) {\n  var ret;\n  if (!params) {\n    // if it's uncontested, then just return the addition.\n    ret = addition;\n  } else if (braintree_util.isArray(params)) {\n    // if the existing value is an array, then concat it.\n    ret = params.concat(addition);\n  } else if (!braintree_util.isObject(params) || !braintree_util.isObject(addition)) {\n    // if the existing value is not an array, and either are not objects, arrayify it.\n    ret = [params].concat(addition);\n  } else {\n    // else merge them as objects, which is a little more complex\n    ret = mergeObjects(params, addition);\n  }\n  return ret;\n}\n;\n\n// Merge two *objects* together. If this is called, we've already ruled\n// out the simple cases, and need to do the for-in business.\nfunction mergeObjects(params, addition) {\n  for (var i in addition) if (i && addition.hasOwnProperty(i)) {\n    params[i] = mergeParams(params[i], addition[i]);\n  }\n  return params;\n}\n;","map":{"version":3,"names":["util","require","braintree_util","exports","parse","querystring_parse","qs","sep","eq","unesc","split","map","pieceParser","unescape","reduce","mergeParams","s","decodeURIComponent","replace","parsePiece","key","val","arguments","length","shift","join","isString","isNaN","numVal","toString","sliced","exec","ret","tail","head","params","addition","isArray","concat","isObject","mergeObjects","i","hasOwnProperty"],"sources":["C:/Users/Vivek Jariwala/Documents/AngularProjects/BraintreePaymentProcessor/node_modules/braintree/vendor/querystring.node.js.511d6a2/querystring-parse.js"],"sourcesContent":["/* eslint-disable */\n/*\n * querystring-parse.js\n *  - node.js module providing \"parse\" method to turn query strings into js objects\n *\n * Chad Etzel\n *\n * Based on YUI \"querystring-parse.js\" module\n * http://github.com/isaacs/yui3/tree/master/src/querystring/js\n *\n * Copyright (c) 2009, Yahoo! Inc. and Chad Etzel\n * BSD License (see LICENSE.md for info)\n */\n\n\nvar util = require(\"util\"),\n  braintree_util = require(\"./util\");\n\nexports.parse = querystring_parse;\n\n/**\n * <p>The querystring module adds support for serializing JavaScript objects into\n * query strings and parsing JavaScript objects from query strings format.</p>\n *\n * <p>The <code>querystring</code> module is a rollup of <code>querystring-parse</code> and\n * <code>querystring-stringify</code>.</p>\n *\n * <p>As their names suggest, <code>querystring-parse</code> adds support for parsing\n * Query String data (querystring.parse) and <code>querystring-stringify</code> for serializing\n * JavaScript data into Query Strings (querystring.stringify).  You may choose to\n * include either of the submodules individually if you don't need the\n * complementary functionality, or include the rollup for both.</p>\n *\n * @module querystring\n */\n\n/**\n * Provides parse method to accept Query Strings and return native\n * JavaScript objects.\n *\n * @module querystring\n * @submodule querystring-parse\n * @for querystring\n * @static\n */\nfunction querystring_parse (qs, sep, eq, unesc) {\n  return qs.split(sep || \"&\")\n    .map(pieceParser(eq || \"=\", unesc || unescape))\n    .reduce(mergeParams, {});\n};\n\nfunction unescape (s) {\n    return decodeURIComponent(s.replace(/\\+/g, ' '));\n};\n\n\n// Parse a key=val string.\n// These can get pretty hairy\n// example flow:\n// parse(foo[bar][][bla]=baz)\n// return parse(foo[bar][][bla],\"baz\")\n// return parse(foo[bar][], {bla : \"baz\"})\n// return parse(foo[bar], [{bla:\"baz\"}])\n// return parse(foo, {bar:[{bla:\"baz\"}]})\n// return {foo:{bar:[{bla:\"baz\"}]}}\nfunction pieceParser (eq, unesc) {\n  return function parsePiece (key, val) {\n    if (arguments.length !== 2) {\n      // key=val, called from the map/reduce\n      key = key.split(eq);\n      return parsePiece(\n        unesc(key.shift()),\n        unesc(key.join(eq))\n      );\n    }\n    key = key.replace(/^\\s+|\\s+$/g, '');\n    if (braintree_util.isString(val)) {\n      val = val.replace(/^\\s+|\\s+$/g, '');\n      // convert numerals to numbers\n      if (!isNaN(val)) {\n        var numVal = +val;\n        if (val === numVal.toString(10)) val = numVal;\n      }\n    }\n    var sliced = /(.*)\\[([^\\]]*)\\]$/.exec(key);\n    if (!sliced) {\n      var ret = {};\n      if (key) ret[key] = val;\n      return ret;\n    }\n    // [\"foo[][bar][][baz]\", \"foo[][bar][]\", \"baz\"]\n    var tail = sliced[2],\n      head = sliced[1];\n\n    // array: key[]=val\n    if (!tail) return parsePiece(head, [val]);\n\n    // obj: key[subkey]=val\n    var ret = {};\n    ret[tail] = val;\n    return parsePiece(head, ret);\n  };\n};\n\n// the reducer function that merges each query piece together into one set of params\nfunction mergeParams (params, addition) {\n\tvar ret;\n\n\tif (!params){\n\t\t// if it's uncontested, then just return the addition.\n\t\tret = addition;\n\t} else if (braintree_util.isArray(params)) {\n\t\t// if the existing value is an array, then concat it.\n\t\tret = params.concat(addition);\n\t} else if (!braintree_util.isObject(params) || !braintree_util.isObject(addition)) {\n\t\t// if the existing value is not an array, and either are not objects, arrayify it.\n\t\tret = [params].concat(addition);\n\t} else {\n\t\t// else merge them as objects, which is a little more complex\n\t\tret = mergeObjects(params, addition);\n\t}\n\treturn ret;\n};\n\n\n// Merge two *objects* together. If this is called, we've already ruled\n// out the simple cases, and need to do the for-in business.\nfunction mergeObjects (params, addition) {\n  for (var i in addition) if (i && addition.hasOwnProperty(i)) {\n    params[i] = mergeParams(params[i], addition[i]);\n  }\n  return params;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}